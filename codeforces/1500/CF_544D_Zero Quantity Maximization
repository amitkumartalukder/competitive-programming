Problem Recap :

You are given two arrays:

a[ ]

b[ ]

Both have n numbers.

You are allowed to choose one real number d (it does NOT have to be an integer).

Then a new array c[ ] is created using this rule:

c[i] = d * a[i] + b[i]


Your task is to choose d in such a way that the number of zero values in array c is as large as possible.

You only need to output how many zeros you can get at best.

Key Intuition (the most important idea)
 One index → one required value of d

For any index i, the value c[i] becomes zero only if:

d * a[i] + b[i] = 0


Rearranging this:

d = -b[i] / a[i]


So each index is basically saying:

“I will become zero only if d equals this specific value.”

This is the heart of the problem.

Important Observation

You are allowed to choose only one value of d

Different indices may want different values of d

If multiple indices want the same d, all of them can become zero together

So the problem becomes:

Which value of d is requested by the most indices?

That value of d will give the maximum number of zeros.

Special Case: When a[i] = 0

Let’s look at what happens here:

c[i] = d * 0 + b[i] = b[i]


So:

If b[i] = 0
→ c[i] is always zero, no matter what d is
→ we can safely count it

If b[i] ≠ 0
→ c[i] can never become zero
→ we ignore it

We count all (a[i] = 0 AND b[i] = 0) separately.

How We Track the Best d
Why not store d as a decimal?

Because d = -b[i] / a[i] can be a fraction, like:

1/2, 2/4, 3/6


All of these mean the same value, but decimals can cause precision problems.

Smart Trick :

Instead of calculating d as a decimal, we store it as a reduced fraction:

d = x / y   where:
x = -b[i]
y = a[i]


Then:

Divide both x and y by their GCD

Make sure y is always positive

Use (x, y) as a key in a map

This guarantees:

Same d → same (x, y)

Different d → different keys

Step-by-Step Solution Flow

Initialize base = 0
(for all a[i] = 0 and b[i] = 0)

Create a map to count how many times each (x, y) appears

For each index:

If a[i] = 0:

If b[i] = 0, increase base

Otherwise ignore

Else:

Compute x = -b[i], y = a[i]

Reduce the fraction

Normalize sign

Increase frequency of (x, y)

Find the maximum frequency in the map

Final answer = base + maximum frequency
